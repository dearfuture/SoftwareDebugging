; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\dig\dbg\author\code\chap22\SecChk\SecChk\SecChk.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?ng@@3HA					; ng
PUBLIC	?SZ_INPUT@@3PADA				; SZ_INPUT
_BSS	SEGMENT
?ng@@3HA DD	01H DUP (?)				; ng
_BSS	ENDS
_DATA	SEGMENT
?SZ_INPUT@@3PADA DB 'j', 01H, '3', 0c0H, 'PPP', 0baH, 0bH, 05H, 0d8H, 'w', 0ffH
	DB	0d2H, 'H', 085H, 0c0H, 't', 0edH, '222221111111111110JB', 00H ; SZ_INPUT
_DATA	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?_crt_debugger_hook@@YAXH@Z			; _crt_debugger_hook
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\dig\dbg\author\code\chap22\secchk\secchk\secchk.cpp
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ?_crt_debugger_hook@@YAXH@Z
_TEXT	SEGMENT
__Reserved$ = 8						; size = 4
?_crt_debugger_hook@@YAXH@Z PROC			; _crt_debugger_hook, COMDAT

; 24   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 25   :     /* assign 0 to _debugger_hook_dummy so that the function is not folded in retail */
; 26   :     (_Reserved);
; 27   : 	ng=0;

	mov	DWORD PTR ?ng@@3HA, 0			; ng

; 28   : 	MessageBox(NULL,"","",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 29   :     __asm int 3;

	int	3

; 30   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_crt_debugger_hook@@YAXH@Z ENDP			; _crt_debugger_hook
_TEXT	ENDS
PUBLIC	?MyCrtDbggerHook@@YAXH@Z			; MyCrtDbggerHook
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?MyCrtDbggerHook@@YAXH@Z
_TEXT	SEGMENT
__Reserved$ = 8						; size = 4
?MyCrtDbggerHook@@YAXH@Z PROC				; MyCrtDbggerHook, COMDAT

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 33   :     /* assign 0 to _debugger_hook_dummy so that the function is not folded in retail */
; 34   :     (_Reserved);
; 35   : 	ng=0;

	mov	DWORD PTR ?ng@@3HA, 0			; ng

; 36   : 	MessageBox(NULL,"","",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 37   :     __asm int 3;

	int	3

; 38   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?MyCrtDbggerHook@@YAXH@Z ENDP				; MyCrtDbggerHook
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?HandleInput@@YAXPBD@Z				; HandleInput
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	_strcpy:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?HandleInput@@YAXPBD@Z
_TEXT	SEGMENT
_szBuffer$ = -40					; size = 31
__$ArrayPad$ = -4					; size = 4
_lpszInput$ = 8						; size = 4
?HandleInput@@YAXPBD@Z PROC				; HandleInput, COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 57   : 	TCHAR szBuffer[31];
; 58   : 	strcpy(szBuffer,lpszInput);

	mov	eax, DWORD PTR _lpszInput$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 59   : 	OutputDebugString(szBuffer);

	mov	esi, esp
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 60   : 	//process the content in buffer...
; 61   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@HandleInpu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@HandleInpu:
	DD	1
	DD	$LN4@HandleInpu
$LN4@HandleInpu:
	DD	-40					; ffffffd8H
	DD	31					; 0000001fH
	DD	$LN3@HandleInpu
$LN3@HandleInpu:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?HandleInput@@YAXPBD@Z ENDP				; HandleInput
_TEXT	ENDS
PUBLIC	??_C@_03PMGGPEJJ@?$CFd?6?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?VarCheck@@YAXPBD@Z				; VarCheck
EXTRN	_strcat:PROC
EXTRN	__imp__sprintf:PROC
EXTRN	_strlen:PROC
;	COMDAT ??_C@_03PMGGPEJJ@?$CFd?6?$AA@
CONST	SEGMENT
??_C@_03PMGGPEJJ@?$CFd?6?$AA@ DB '%d', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?VarCheck@@YAXPBD@Z
_TEXT	SEGMENT
_j$ = -88						; size = 4
_szThdBuffer$ = -76					; size = 3
_m$ = -61						; size = 1
_szSndBuffer$ = -52					; size = 5
_lpsz$ = -36						; size = 4
_szFstBuffer$ = -24					; size = 3
_n$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpszInput$ = 8						; size = 4
?VarCheck@@YAXPBD@Z PROC				; VarCheck, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 64   : 	int n;
; 65   : 	TCHAR szFstBuffer[3];
; 66   : 	LPTSTR lpsz;
; 67   : 	TCHAR szSndBuffer[5]="";

	mov	al, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
	mov	BYTE PTR _szSndBuffer$[ebp], al
	xor	eax, eax
	mov	DWORD PTR _szSndBuffer$[ebp+1], eax

; 68   : 	char m=9;

	mov	BYTE PTR _m$[ebp], 9

; 69   : 	TCHAR szThdBuffer[3];
; 70   : 	int j;
; 71   : 	j=n=m=strlen(lpszInput);

	mov	eax, DWORD PTR _lpszInput$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	BYTE PTR _m$[ebp], al
	movsx	ecx, BYTE PTR _m$[ebp]
	mov	DWORD PTR _n$[ebp], ecx
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _j$[ebp], edx

; 72   : 	sprintf(szFstBuffer,"%d\n",n);

	mov	esi, esp
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_03PMGGPEJJ@?$CFd?6?$AA@
	lea	ecx, DWORD PTR _szFstBuffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 73   : 	OutputDebugString(szFstBuffer);

	mov	esi, esp
	lea	eax, DWORD PTR _szFstBuffer$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 74   : 
; 75   : 	lpsz=szThdBuffer;

	lea	eax, DWORD PTR _szThdBuffer$[ebp]
	mov	DWORD PTR _lpsz$[ebp], eax

; 76   : 	strcpy(lpsz,lpszInput);

	mov	eax, DWORD PTR _lpszInput$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpsz$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 77   : 	strcat(szSndBuffer,lpsz);

	mov	eax, DWORD PTR _lpsz$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szSndBuffer$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 78   : 	OutputDebugString(szSndBuffer);

	mov	esi, esp
	lea	eax, DWORD PTR _szSndBuffer$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 79   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@VarCheck
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@VarCheck:
	DD	3
	DD	$LN6@VarCheck
$LN6@VarCheck:
	DD	-24					; ffffffe8H
	DD	3
	DD	$LN3@VarCheck
	DD	-52					; ffffffccH
	DD	5
	DD	$LN4@VarCheck
	DD	-76					; ffffffb4H
	DD	3
	DD	$LN5@VarCheck
$LN5@VarCheck:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	84					; 00000054H
	DB	104					; 00000068H
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN4@VarCheck:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	83					; 00000053H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN3@VarCheck:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	70					; 00000046H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?VarCheck@@YAXPBD@Z ENDP				; VarCheck
_TEXT	ENDS
PUBLIC	?EmptyFunc@@YAXXZ				; EmptyFunc
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?EmptyFunc@@YAXXZ
_TEXT	SEGMENT
?EmptyFunc@@YAXXZ PROC					; EmptyFunc, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EmptyFunc@@YAXXZ ENDP					; EmptyFunc
_TEXT	ENDS
PUBLIC	?UninitialCheck@@YAHXZ				; UninitialCheck
EXTRN	__RTC_UninitUse:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?UninitialCheck@@YAHXZ
_TEXT	SEGMENT
$T60249 = -293						; size = 1
$T60250 = -281						; size = 1
$T60251 = -269						; size = 1
_j$ = -68						; size = 4
_lpsz2$ = -56						; size = 4
_lpsz3$ = -44						; size = 4
_lpsz$ = -32						; size = 4
_m$ = -8						; size = 4
?UninitialCheck@@YAHXZ PROC				; UninitialCheck, COMDAT

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T60250[ebp], 0
	mov	BYTE PTR $T60249[ebp], 0
	mov	BYTE PTR $T60251[ebp], 0

; 85   : 	int m,n;
; 86   : 	LPCTSTR lpsz;
; 87   : 	LPCTSTR lpsz3,lpsz2=lpsz;

	cmp	BYTE PTR $T60249[ebp], 0
	jne	SHORT $LN3@UninitialC
	push	OFFSET $LN4@UninitialC
	call	__RTC_UninitUse
	add	esp, 4
$LN3@UninitialC:
	mov	eax, DWORD PTR _lpsz$[ebp]
	mov	DWORD PTR _lpsz2$[ebp], eax

; 88   : 	//m=n;
; 89   :     lpsz=lpsz3;

	cmp	BYTE PTR $T60250[ebp], 0
	jne	SHORT $LN5@UninitialC
	push	OFFSET $LN6@UninitialC
	call	__RTC_UninitUse
	add	esp, 4
$LN5@UninitialC:
	mov	BYTE PTR $T60249[ebp], 1
	mov	eax, DWORD PTR _lpsz3$[ebp]
	mov	DWORD PTR _lpsz$[ebp], eax

; 90   :     int j=m;

	cmp	BYTE PTR $T60251[ebp], 0
	jne	SHORT $LN7@UninitialC
	push	OFFSET $LN8@UninitialC
	call	__RTC_UninitUse
	add	esp, 4
$LN7@UninitialC:
	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR _j$[ebp], eax

; 91   :     return m;

	cmp	BYTE PTR $T60251[ebp], 0
	jne	SHORT $LN9@UninitialC
	push	OFFSET $LN8@UninitialC
	call	__RTC_UninitUse
	add	esp, 4
$LN9@UninitialC:
	mov	eax, DWORD PTR _m$[ebp]

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@UninitialC:
$LN8@UninitialC:
	DB	109					; 0000006dH
	DB	0
$LN6@UninitialC:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	51					; 00000033H
	DB	0
$LN4@UninitialC:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	0
?UninitialCheck@@YAHXZ ENDP				; UninitialCheck
_TEXT	ENDS
PUBLIC	??_C@_03GOLGPOF@DBG?$AA@			; `string'
PUBLIC	??_C@_02LFGCCOHG@DB?$AA@			; `string'
PUBLIC	??_C@_0DM@DLCLGHNE@A?5sample?5to?5demo?5security?5check?5@ ; `string'
PUBLIC	??_C@_06BAIBCLCL@AdvDbg?$AA@			; `string'
PUBLIC	_WinMain@16
;	COMDAT ??_C@_03GOLGPOF@DBG?$AA@
CONST	SEGMENT
??_C@_03GOLGPOF@DBG?$AA@ DB 'DBG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFGCCOHG@DB?$AA@
CONST	SEGMENT
??_C@_02LFGCCOHG@DB?$AA@ DB 'DB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DLCLGHNE@A?5sample?5to?5demo?5security?5check?5@
CONST	SEGMENT
??_C@_0DM@DLCLGHNE@A?5sample?5to?5demo?5security?5check?5@ DB 'A sample t'
	DB	'o demo security check for buffer overflow attack.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAIBCLCL@AdvDbg?$AA@
CONST	SEGMENT
??_C@_06BAIBCLCL@AdvDbg?$AA@ DB 'AdvDbg', 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 96   : 	MessageBox(NULL,"A sample to demo security check for buffer overflow attack.",
; 97   : 		"AdvDbg",MB_OK);

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_06BAIBCLCL@AdvDbg?$AA@
	push	OFFSET ??_C@_0DM@DLCLGHNE@A?5sample?5to?5demo?5security?5check?5@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 98   : 	EmptyFunc();

	call	?EmptyFunc@@YAXXZ			; EmptyFunc

; 99   :     UninitialCheck();

	call	?UninitialCheck@@YAHXZ			; UninitialCheck

; 100  : 
; 101  : 	// Call VarCheck function, will not cause any overflow
; 102  : 	VarCheck("DB");

	push	OFFSET ??_C@_02LFGCCOHG@DB?$AA@
	call	?VarCheck@@YAXPBD@Z			; VarCheck
	add	esp, 4

; 103  : 	// Call VarCheck function to cause overflow a little bit,
; 104  : 	// this overflow can triger variable check failure, but not GS failure
; 105  : 	VarCheck("DBG");

	push	OFFSET ??_C@_03GOLGPOF@DBG?$AA@
	call	?VarCheck@@YAXPBD@Z			; VarCheck
	add	esp, 4

; 106  : 	//
; 107  : 	// Significant overflow, which will triger GS failure in release build.
; 108  : 	HandleInput(SZ_INPUT);

	push	OFFSET ?SZ_INPUT@@3PADA			; SZ_INPUT
	call	?HandleInput@@YAXPBD@Z			; HandleInput
	add	esp, 4

; 109  : 	_crt_debugger_hook(0);

	push	0
	call	?_crt_debugger_hook@@YAXH@Z		; _crt_debugger_hook
	add	esp, 4

; 110  : 	return 0;

	xor	eax, eax

; 111  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
PUBLIC	?RTC_CheckStackVars@@YIXPAXPAU_RTC_framedesc@@@Z ; RTC_CheckStackVars
EXTRN	?_RTC_StackFailure@@YAXPAXPBD@Z:PROC		; _RTC_StackFailure
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?RTC_CheckStackVars@@YIXPAXPAU_RTC_framedesc@@@Z
_TEXT	SEGMENT
_i$60156 = -68						; size = 4
_pVarDesc$ = -56					; size = 4
__RetAddr$ = -44					; size = 4
_pdwFense$ = -32					; size = 4
__Fd$ = -20						; size = 4
__Frame$ = -8						; size = 4
?RTC_CheckStackVars@@YIXPAXPAU_RTC_framedesc@@@Z PROC	; RTC_CheckStackVars, COMDAT
; __Frame$ = ecx
; __Fd$ = edx

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __Fd$[ebp], edx
	mov	DWORD PTR __Frame$[ebp], ecx

; 115  : 	DWORD* pdwFense,_RetAddr;
; 116  : 
; 117  : 	_RTC_vardesc * pVarDesc= _Fd->variables;

	mov	eax, DWORD PTR __Fd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pVarDesc$[ebp], ecx

; 118  : 
; 119  : 	for( int i=0; i< _Fd->varCount;i++)

	mov	DWORD PTR _i$60156[ebp], 0
	jmp	SHORT $LN6@RTC_CheckS
$LN5@RTC_CheckS:
	mov	eax, DWORD PTR _i$60156[ebp]
	add	eax, 1
	mov	DWORD PTR _i$60156[ebp], eax
$LN6@RTC_CheckS:
	mov	eax, DWORD PTR __Fd$[ebp]
	mov	ecx, DWORD PTR _i$60156[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN7@RTC_CheckS

; 120  : 	{
; 121  : 		pdwFense=(DWORD*)((DWORD)_Frame+
; 122  : 			(DWORD)pVarDesc->addr-sizeof(DWORD));

	mov	eax, DWORD PTR _pVarDesc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Frame$[ebp]
	lea	eax, DWORD PTR [edx+ecx-4]
	mov	DWORD PTR _pdwFense$[ebp], eax

; 123  : 		if(*pdwFense!=0xCCCCCCCC)

	mov	eax, DWORD PTR _pdwFense$[ebp]
	cmp	DWORD PTR [eax], -858993460		; ccccccccH
	je	SHORT $LN3@RTC_CheckS
	jmp	SHORT $TAG_CORRUPT_FOUND$60165

; 124  : 			goto TAG_CORRUPT_FOUND;

	jmp	SHORT $TAG_CORRUPT_FOUND$60165
$LN3@RTC_CheckS:

; 125  : 		pdwFense=(DWORD*)((DWORD)_Frame+
; 126  : 			(DWORD)pVarDesc->addr+pVarDesc->size);

	mov	eax, DWORD PTR _pVarDesc$[ebp]
	mov	ecx, DWORD PTR __Frame$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pVarDesc$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _pdwFense$[ebp], ecx

; 127  : 		if(*pdwFense!=0xCCCCCCCC)

	mov	eax, DWORD PTR _pdwFense$[ebp]
	cmp	DWORD PTR [eax], -858993460		; ccccccccH
	je	SHORT $LN1@RTC_CheckS
$TAG_CORRUPT_FOUND$60165:

; 128  : 		{
; 129  : TAG_CORRUPT_FOUND:
; 130  : 			_asm mov edx,dword ptr [ebp+4] ;

	mov	edx, DWORD PTR [ebp+4]

; 131  : 			_asm mov _RetAddr, edx;

	mov	DWORD PTR __RetAddr$[ebp], edx

; 132  : 			_RTC_StackFailure((void *)_RetAddr,pVarDesc->name);

	mov	eax, DWORD PTR _pVarDesc$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __RetAddr$[ebp]
	push	edx
	call	?_RTC_StackFailure@@YAXPAXPBD@Z		; _RTC_StackFailure
	add	esp, 8
$LN1@RTC_CheckS:

; 133  : 		}
; 134  : 
; 135  : 		pVarDesc++;

	mov	eax, DWORD PTR _pVarDesc$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pVarDesc$[ebp], eax
	jmp	SHORT $LN5@RTC_CheckS
$LN7@RTC_CheckS:

; 136  : 	}
; 137  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RTC_CheckStackVars@@YIXPAXPAU_RTC_framedesc@@@Z ENDP	; RTC_CheckStackVars
_TEXT	ENDS
END
